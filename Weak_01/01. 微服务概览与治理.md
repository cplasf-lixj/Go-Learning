# 微服务概览

	## 单体架构

​	单体架构比较初级，典型的三级架构，前端(Web/手机端)+中间业务逻辑层+数据库层。

​	单体架构的应用比较容易部署、测试，在项目初期，单体应用可以很好的运行。但是，随着需求的增加，开发人员的增加，代码库飞速的膨胀，单体应用变得越来越臃肿，可维护性和灵活性逐渐降低，维护成本越来越高。

​	缺点：

​		• 复杂性高

​			一个庞大的项目包含的模块非常多、模块的边界模糊、依赖关系不清晰、代码质量参差不齐、混乱的堆砌在一起。整个项目非常复杂，每次修改代码或添加一个简单的功能，都可以带来隐含的缺陷。

​		• 技术债务

​			随着时间推移、需求变更和人员更迭，会逐渐形成应用程序的技术债务。

​		• 部署频率低

​			单体应用中，每次功能的变更或缺陷的修复都会导致重新部署整个应用。部署耗时长、影响范围大、风险高，这使得单体应用的项目上线部署的频率较低。

​		• 扩展能力受限

​			单体应用智能对整体进行扩展，无法根据业务模块的需要进行伸缩。

​		• 阻碍技术创新

​			单体应用往往使用统一的技术平台或方案解决所有的问题，团队中的每个成员都必须使用相同的开发语言和框架，要想引入新的 框架或新技术平台会非常困难。

	## 分布式架构

​	中级架构，分布式应用，中间层分布式+数据库分布式，是单体架构的并发扩展，将一个大的系统划分为多个业务模块，业务模块分别部署在不同的服务器上，各个业务模块之间通过接口进行数据交互。数据库也大量采用分布式数据库，如redis、ES、solor等。通过LVS/Nginx代理应用，将用户请求均衡发负载到不同的服务器上。

​	![img](https://crimsonromance.github.io/2019/03/23/%E5%9B%9B%E7%A7%8D%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E3%80%81Serverless%E6%9E%B6%E6%9E%84/2.png)

​	该架构相对于单体架构来说，这种架构提供了负载均衡的能力，大大提高了系统单负载能力，解决了网站高并发的请求。

​	特点：

​		• 降低了耦合度：把模块拆分，使用接口通信，降低模块之间的耦合度。

​		• 责任清晰： 把项目拆分成若干个子项目，不同的团队负责不同的子项目。

​		• 扩展方便： 增加功能时只需要再增加一个子项目，调用其他系统的接口就可以。

​		• 部署方便： 可以灵活的进行分布式部署。

​		• 提高代码的复用性： 比如service层，如果不采用分布式rest服务方式架构就会在手机wap商城，微信商城，pc，android，ios每个端都要写一个service层逻辑，难以维护一起升级。这时可以采用分布式rest服务，公用一个service层。

​	缺点：

​		• 系统之家的交互要使用远程通信，接口开发增大工作量，但是利大于弊。

## 微服务架构

​	微服务架构，主要是中间层分解，将系统拆分成很多小应用（微服务），微服务可以部署在不同的服务器上，也可以部署在相同的服务器不同的容器上。但应用的故障不会影响到其他应用，单应用的负载也不会影响到其他应用，其代表框架有Spring cloud、Dubbo等。

![3](https://crimsonromance.github.io/2019/03/23/%E5%9B%9B%E7%A7%8D%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E3%80%81Serverless%E6%9E%B6%E6%9E%84/3.png)

​	特点：

​		• 易于开发和维护：一个微服务只关注一个特定的业务共，业务清晰、代码量较少。开发和维护单个微服务相对简单。而整个应用是由若干个微服务构建而成的，所以整个应用也会被维持在一个可控状态。

​		• 单个微服务启动较快： 单个微服务代码量较少，所以启动会比较快。

​		• 局部修改容易部署：单体应用只要有修改，就需要重新部署整个应用，微服务解决了这样的问题。一般来说，对某个微服务进行修改，只需要重新部署这个服务即可。

​		• 技术栈不受限：在微服务架构中，可以结合项目业务及团队的特点，合理的选择技术栈。例如某些服务可使用关系型数据库MySQL；某些微服务有图形计算的需求，可以使用Neo4j；甚至可根据需要，部分微服务使用Java开发，部分微服务使用Node.js开发。

​	面临的挑战：

​		• 运维要求较高：更多的服务意味着更多的运维投入。在单体架构中，只需要保证一个应用的正常运行。而在微服务中，需要保证几十甚至几百个服务服务的正常运行与协作，这给运维带来了很大的挑战。

​		• 分布式固有的复杂性：使用微服务构建的是分布式系统。对于一个分布式系统，系统容错、网络延迟、分布式事务等都会带来巨大的挑战。

​		• 接口调整成本高：微服务之间通过接口进行通信。如果修改某一个微服务的API，可能所有使用了该接口的微服务都需要做调整。

​		• 重复劳动：很多服务可能都会使用到相同的功能，而这个功能并没有达到分解为一个微服务的程度，这个时候，可能各个服务都会开发这一功能，从而导致代码重复。尽管可以使用共享库来解决这个问题（例如可以将这个功能封装成公共组件，需要该功能的微服务引用该组件），但共享库在多语言环境下就不一定行得通了。

## Serverless架构

![4](https://crimsonromance.github.io/2019/03/23/%E5%9B%9B%E7%A7%8D%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E3%80%81Serverless%E6%9E%B6%E6%9E%84/4.png)

​	2014年11月14日，亚马逊AWS发布了新产品Lambda。当时Lambda被描述为：一种计算服务，根据时间运行用户的代码，无需关心底层的计算资源。从某种意义上来说，Lambda姗姗来迟，它像云计算的PaaS理念：客户只管业务，无需担心存储和计算资源。在此前不久，2014年10月22日，谷歌收购了实时后端数据库创业公司Firebase。Firebase声称开发者只需引用一个API库文件就可以使用标准REST API的各种接口对数据进行读写操作，只需编写HTML＋CSS＋JavaScrip前端代码，不需要服务器端代码（如需整合，也极其简单）。

  相对于上两者，Facebook 在2014年二月收购的 Parse，则侧重于提供一个通用的后台服务。这些服务被称为Serverless或no sever。想到PaaS（平台即服务）了是吗？很像，用户不需要关心基础设施，只需要关心业务，这是迟到的PaaS，也是更实用的PaaS。这很有可能将会变革整个开发过程和传统的应用生命周期，一旦开发者们习惯了这种全自动的云上资源的创建和分配，或许就再也回不到那些需要微应用配置资源的时代里去了。

  Serverless架构能够让开发者在构建应用的过程中无需关注计算资源的获取和运维，由平台来按需分配计算资源并保证应用执行的SLA（服务等级协议），按照调用次数进行计费，有效的节省应用成本。ServerLess的架构如上图所示。其优点如下所示：	

​		• 低运营成本：在业务突发性极高的场景下，系统为了应对业务高峰，必须构建能够应对峰值需求的系统，这个系统在大部分时间是空闲的，这就导致了严重的资源浪费和成本上升。在微服务架构中，服务需要一直运行，实际上在高负载情况下每个服务都不止一个实例，这样才能完成高可用性；在Serverless架构下，服务将根据用户的调用次数进行计费，按照云计算pay-as-you-go原则，如果没有东西运行，你就不必付款，节省了使用成本。同时，用户能够通过共享网络、硬盘、CPU等计算资源，在业务高峰期通过弹性扩容方式有效的应对业务峰值，在业务波谷期将资源分享给其他用户，有效的节约了成本。

​		• 简化设备运维：在原有的IT体系中，开发团队即需要维护应用程序，同时还要维护硬件基础设施；Serverless架构中，开发人员面对的将是第三方开发或自定义的API 和URL，底层硬件对于开发人员透明化了，技术团队无需再关注运维工作，能够更加专注于应用系统开发。

​		• 提升可维护性：Serverless架构中，应用程序将调用多种第三方功能服务，组成最终的应用逻辑。目前，例如登陆鉴权服务，云数据库服务等第三方服务在安全性、可用性、性能方面都进行了大量优化，开发团队直接集成第三方的服务，能够有效的降低开发成本，同时使得应用的运维过程变得更加清晰，有效的提升了应用的可维护性。

​		• 更快的开发速度：这一点在现在互联网创业公司得到很好的体现，创业公司往往开始由于人员和资金等问题，不可能每个产品线都同时进行，这时候就可以考虑第三方的Baas平台，比如使用微信的用户认证、阿里云提供的RDS，极光的消息推送，第三方支付及地理位置等等，能够很快进行产品开发的速度，把工作重点放在业务实现上，把产品更快的推向市场。
但ServerLess架构也有其缺点：

​		• 厂商平台绑定：平台会提供Serverless架构给大玩家，比如AWS Lambda，运行它需要使用AWS指定的服务，比如API网关，DynamoDB，S3等等，一旦你在这些服务上开发一个复杂系统，你会粘牢AWS，以后只好任由他们涨价定价或者下架等操作，个性化需求很难满足，不能进行随意的迁移或者迁移的成本比较大，同时不可避免带来一些损失。Baas行业内一个比较典型的事件，2016年1月19日Facebook关闭曾经花巨额资金收购的Parse，造成用户不得不迁移在这个平台中产生一年多的数据，无疑需要花费比较大的人力和时间成本。

​		• 成功案例比较少，没有行业标准：目前的情况也只适合简单的应用开发，缺乏大型成功案例的推动。对于Serverless缺乏统一的认知以及相应的标准，无法适应所有的云平台。

## 微服务定义

​	围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以*全自动独立部署*，可以*使用不同的编程语言*和*数据存储技术*。**微服务架构通过业务拆分实现服务组件化，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署**，使得整个系统变得清晰灵活：

​	• 原子服务:	关注单一业务

​	• 独立进程:	独立部署和交付

​	• 隔离部署

​	• 去中心化服务治理

​	**缺点**:

​	• 基础设施的建设、复杂度高

## 微服务不足

​	• 微服务应用是分布式系统，由此会带来固有的复杂性。开发者不得不使用RPC或者消息传递，来实现进程间通信；此外，必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题。

​	• 分区的数据库架构，同时更新多个业务主体的事物很普遍。这种事务对于单体式应用来说很容易，因为只有一个数据库。在微服务架构应用中，需要更新不同服务所使用的不同的数据库，从而对开发者提出了更高的要求和挑战。

​	• 测试一个基于微服务架构的应用也是很复杂的任务。

​	• 服务模块间的依赖，应用的升级有可能会波及多个服务模块的修改。

​	• 对运维基础设施的挑战比较大。

## 组件服务化

​	传统实现组件的方式是通过库(library)，库是和应用一起运行在进程中的，库的局部变化意味着整个应用的重新部署。

​	通过服务来实现组件化，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需重新部署对应的服务进程。

​	用Go实施一个微服务：

​		• kit：一个微服务的基础库

​		• service：业务代码 + kit依赖 + 第三方依赖组成的业务微服务

​		• RPC + message queue：轻量级通讯

​	PS: 本质上等同于，多个微服务组合(compose)完成了一个完整的用户场景(usecase)。

## 去中心化

​	• 数据去中心化	微服务每个业务独占数据库、独占cache

​	• 治理去中心化	避免集中式的处理或分发密集流量热点

​	• 技术去中心化	避免一种技术方式

## 基础设施自动化

​	无自动化不微服务，自动化包括测试和部署。单一进程的传统应用被拆分为一系列的多进程服务后，意味着开发、调试、测试、监控和部署的复杂都会相应增大，必须要有合适的自动化基础设施来支持微服务架构模式，否则开发、运维成本将大大增加。

​	• CICD：Gitlab + Gitlab Hooks + kubernetes

​	• Testing：测试环境、单元测试、API自动化测试

​	• 在线运行时：kubernetes, 以及一系列Prometheus、ELK、Control Panle。

## 可用性 &  兼容性设计

​	微服务架构采用粗粒度的进程间通信，引入了额外的复杂性和需要处理的问题，如网络延迟、消息格式、负载均衡和容错，忽略其中任何一点都属于对“分布式技术的误解。”

​	• 隔离

​	• 超时控制

​	• 负载保护

​	• 限流

​	• 降级

​	• 重试

​	• 负载均衡

​	一旦采用了微服务架构模式，那么在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，时刻谨记保持服务契约（接口）的兼容性。

​	发送时要保守，接收时要开放。发送时要保守，意味着最小化的传送必要的信息，接收时要开放，意味着更大限度的容忍冗余的数据，保证兼容性。



# 微服务设计

## API Gateway 

### 	APP-INTERFACE(Backend For Frontend)

​	**优点：**

​	• 轻量交互：协议精简、聚合

​	• 差异服务：数据裁剪以及聚合、针对终端定制化API

​	• 动态升级：原有系统兼容升级，更新服务而非协议

​	• 沟通效率提升，协议模式演讲为移动业务+网关小组。

​	**PS：BFF可以认为是一种适配服务，将后端的微服务进行适配，向无线端设备暴露友好和统一的API，方便无线设备接入访问后端服务。**

​	**缺点：**

​	整个app-interface属于single point offailure，严重代码缺陷或者流量洪峰可能引发集群宕机。

​	• 单个模块也会导致后续业余集成复杂度高，根据康威法则，单块的无线BFF和多个团队之间就出现不匹配问题，团队之间沟通协调成本高，交付效率低下。

​	• 很多跨横切面逻辑，比如安全认证，日志监控吗，限流熔断等。随着时间的推移，代码变得越来越复杂，技术越堆越多。

	### 	API Gateway

​		跨横切面(Cross-Cutting Concens)的功能，需要协调更新框架升级发版（路由、认证、限流、安全），依次全部上沉，引入了*<font color=orange>API Gateway</font>*，把业务集成度高的BFF层和通用功能服务层API Gateway进行了分层处理。

​		在新的架构中，网关承担了重要的角色，它是解耦拆分和后续升级迁移的利器。在网关的配合下，单独BFF实现了解耦拆分，各业务线团队可以独立开发和交付各自的微服务，研发效率大大提升。另外，把跨横切面逻辑从BFF剥离到网关上去以后，BFF的开发人员可以更加专注业务逻辑交付，实现了架构上的关注分离(Separation of Concerns)。

​		移动端 -> API  Gateway -> BFF -> Mircoservices, 在FE Web业务中，BFF可以是nodejs来做服务端渲染(SSR, Service-Side Rendering), 注意这里忽略了上游的CND、4/7层负载均衡(ELB)。

	### 	Mircoservice划分

​		微服务架构时遇到的第一个问题就是如何划分服务的边界。在实际项目中通常会采用两种不同的方式划分服务边界，即通过业务职能(Business Capability)或是DDD的限界上下文(Bounded Context)。

​		• Business Capability

​			由公司内部不同部门提供的只能。例如客户服务部门提供客户服务的职能，财务部门提供财务相关的职能。

​		• Bounded Context

​			限界上下文是DDD中用来划分不同业务边界的元素，这里业务边界的含义是“解决不同业务问题”的问题域和队员的解决方案域，为了解决某种类型的业务问，贴近领域知识，也就是业务。

​		CQRS(Command Query Responsibility Segregation)，将应用程序分为两部分：命令端和查询端。命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新。

	### 	Mircoservice安全

​		对于外网的请求来说，我们通常在APIGateway进行统一的认证拦截，一旦认证成功，我们会使用Header方式通过RPC元数据传递的方式带到BFF层，BFF获取后把身份信息注入到应用的Context中，BFF到其他下层的微服务，建议是直接在RPC Request中带入用户身份信息(UserID)请求服务。

​		• API Gateway -> BFF -> Service

​		• Biz Auth -> UID -> Request Args

​		对于服务内部，一般要区分身份认证和授权。

​		• Full Trust

​		• Half Trust

​		• Zero Trust



# gRPC & 服务发现



# 多集群 & 多租户

